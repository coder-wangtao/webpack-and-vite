1 开始
//1.1webpack 就是一个函数
//1.2.接受的是 webpack.config.js 中的参数，用配置参数对象初始化 `Compiler` 对象
//1.3.初始化插件，对于插件会调用插件的 apply 方法，并且传入 compiler,插件内部会调用 compiler 里 tapable.tap 方法监听事件，等待执行。
//1.4.执行 `compiler` 对象的 `run` 方法开始执行编译

//2.run 方法
(比如 run 执行的时候或调用 tapable 的 run.call 执行 plugin 里的回调)
//2.1 虽然 webpack 只有一个 Compiler，但是每次编译都会产出一个新的 Compilation，这里主要是为了考虑到 watch 模式，它会在启动时先编译一次，然后监听文件变化，如果发生变化会重新开始编译,每次编译都会产出一个新的 Compilation，代表每次的编译结果。

//3.Compilation 逻辑
//3.1 开启编译
//3.2 根据配置文件中的`entry`配置项找到所有的入口
//3.3 从入口文件出发，调用配置的 `loader` 规则，对各模块进行编译
//3.4 loader 先从左向右执行 pitchLoader,再访问到模块资源，再自右向左对模块资源进行转译。（具体看 loader 部分）
//3.5 通过 loader 翻译后的内容一定得是 js 内容，因为最后得走我们 babel-parse，只有 js 才能成编译 AST
//3.6 找出此模块所依赖的模块，再对依赖模块进行编译
//3.6.1 先把源代码编译成 [AST]
//3.6.2 在 `AST` 中查找 `require` 语句，找出依赖的模块名称和绝对路径
//3.6.3 将依赖模块的信息 push 到该模块的 `dependencies` 属性中
//3.7 生成转译后的源代码
//3.8 对依赖模块进行编译,递归执行。（对 `module 对象`中的 `dependencies` 进行递归执行 `buildModule` ）
//3.9 等所有模块都编译完成后，根据模块之间的依赖关系，组装代码块 `chunk`（一般来说，每个入口文件会对应一个代码块`chunk`，每个代码块`chunk`里面会放着本入口模块和它依赖的模块）
//3.10 根据 chunk 和 ejs 模版，生成最后的输出的 js 代码
//3.11 确定好输出内容之后，根据配置的输出路径和文件名，将文件内容写入到文件系统（这里就是硬盘）
(比如 compiler 结束的时候调用 tapable 的 done.call 执行 plugin 里的回调)

//watch
fs.watch 监听模块所有的依赖，当依赖变化，就执行 compile, 新创建 Compilation，执行 Compilation 的编译方法。
