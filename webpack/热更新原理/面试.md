当我们运行 webpack serve 后，webpack-dev-server 会先往客户端代码中添加了两个文件，这两个文件的目的：
1.websocket 相关的代码，用来跟服务端通信 2.客户端接收到最新代码后，更新代码

着还会帮我们启动两个服务：
一个本地 HTTP 服务：这个本地服务会给我们提供编译之后的结果，之后浏览器通过端口请求时，就会请求本地服务中编译之后的内容，默认端口号 8080。
一个 websocket 双向通信服务器：如果有新的模块发生变化，编译成功会以消息的方式通知客户端，让客户端来请求最新代码，并进行客户端的热更新。

然后会以 watch 模式 开始编译，每次编译结束后会生成一个唯一的 hash 值。
watch 模式：使用监控模式开始启动 webpack 编译，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，每次编译都会产生一个唯一的 hash 值。

这里可能有同学要问了：为什么客户端会有两个 hash 值？
lastHash：上一次接收到的 hash
currentHash：这一次接收到的 hash
这么设计的用意：服务端不知道现在客户端的 hash 是多少，万一此时又连接一个客户端（多窗口的场景）怎么办？
所以这里需要客户端将上一次的 hash 返回给服务端，服务端通过比较后才返回变更的代码块。

如果每次文件改变都重新编译，那性能跟得上吗？
这里为了提升性能，webpack-dev-server 使用了一个库叫 memfs，它是 Webpack 官方自己写的。
这样每次打包之后的结果并不会进行输出（把文件写入到硬盘上会耗费很长的时间），而是将打包后的文件保留在内存中，以此来提升性能。

热更新的核心就是通过 websocket 服务 进行客户端和服务端的同步变更，并没有我们想象中那么复杂。
