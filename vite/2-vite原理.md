1.no-bundle
Vite 是一个提倡 no-bundle 的构建工具，相比于传统的 Webpack，能做到开发时的模块按需编译，而不用先打包完再加载。需要注意的是，我们所说的模块代码其实分为两部分，一部分是源代码，也就是业务代码，另一部分是第三方依赖的代码，即 node_modules 中的代码。所谓的 no-bundle 只是对于源代码而言，对于第三方依赖而言，Vite 还是选择 bundle(打包)，并且使用速度极快的打包器 Esbuild 来完成这一过程，达到秒级的依赖编译速度。

2.为什么在开发阶段我们要对第三方依赖进行预构建? 如果不进行预构建会怎么样？
2.1 首先 Vite 是基于浏览器原生 ES 模块规范实现的 Dev Server，不论是应用代码，还是第三方依赖的代码，理应符合 ESM 规范才能够正常运行。但可惜，我们没有办法控制第三方的打包规范。就目前来看，还有相当多的第三方库仍然没有 ES 版本的产物，比如大名鼎鼎的 react。
2.2 此外，还有一个比较重要的问题——请求瀑布流问题。比如说，知名的 loadsh-es 库本身是有 ES 版本产物的，可以在 Vite 中直接运行。但实际上，它在加载时会发出特别多的请求，导致页面加载的前几秒几都乎处于卡顿状态。我在应用代码中调用了 debounce 方法，这个方法会依赖很多工具函数，每个 import 都会触发一次新的文件请求，因此在这种 依赖层级深 、 涉及模块数量多 的情况下，会触发成百上千个网络请求。不过，在进行依赖的预构建之后， lodash-es 这个库的代码被打包成了一个文件，这样请求的数量会骤然减少，页面加载也快了许多。
2.3 总之，依赖预构建主要做了两件事情：一是将其他格式(如 UMD 和 CommonJS)的产物转换为 ESM 格式，使其在浏览器通过 <script type="module"><script> 的方式正常加载。二是打包第三方库的代码，将各个第三方库分散的文件合并到一起，减少 HTTP 请求数量，避免页面加载性能劣化。而这两件事情全部由性能优异的 Esbuild (基于 Golang 开发)完成，而不是传统的 Webpack/Rollup，所以也不会有明显的打包性能问题，反而是 Vite 项目启动飞快(秒级启动)的一个核心原因。

3.如何开启预构建？
3.1 自动开启
在项目启动成功后，你可以在根目录下的 node_modules 中发现.vite 目录，这就是预构建产物文件存放的目录。并且对于依赖的请求结果，Vite 的 Dev Server 会设置强缓存:缓存过期时间被设置为一年，表示缓存过期前浏览器对 react 预构建产物的请求不会再经过 Vite Dev Server，直接用缓存结果。当然，除了 HTTP 缓存，Vite 还设置了本地文件系统的缓存，所有的预构建产物默认缓存在 node_modules/.vite 目录中。如果以下 3 个地方都没有改动，Vite 将一直使用缓存文件:
//1.package.json 的 dependencies 字段
//2.各种包管理器的 lock 文件
//3.optimizeDeps 配置内容
3.2 手动开启
而少数场景下我们不希望用本地的缓存文件，比如需要调试某个包的预构建结果，我推荐使用下面任意一种方法清除缓存，还有手动开启预构建:
//1.删除 node_modules/.vite 目录。
//2.在 Vite 配置文件中，将 server.force 设为 true 。
//3.命令行执行 npx vite --force 或者 npx vite optimize
3.3 Vite 预构建相关的配置项
//1.Vite 将预构建相关的配置项都集中在 optimizeDeps 属性,entries:通过这个参数你可以自定义预构建的入口文件。
//2.include: 它决定了可以强制预构建的依赖项。
Vite 会根据应用入口( entries )自动搜集依赖，然后进行预构建，这是不是说明 Vite 可以百分百准确地搜集到所有的依赖呢？事实上并不是，某些情况下 Vite 默认的扫描行为并不完全可靠，这就需要联合配置 include 来达到完美的预构建效果了。接下来，我们好好梳理一下到底有哪些需要配置 include 的场景：
场景: 动态 import
动态 import 的路径只有运行时才能确定，无法在预构建阶段被扫描出来。使用动态 import 时 Vite 运行时发现了新的依赖，随之重新进行依赖预构建，并刷新页面。这个过程也叫二次预构建。在一些比较复杂的项目中，这个过程会执行很多次。二次预构建的成本也比较大，因此，我们要尽力避免运行时的二次预构建。具体怎么做呢？你可以通过 include 参数提前声明需要按需加载的依赖。
3.exclude：exclude 是 optimizeDeps 中的另一个配置项，与 include 相对，用于将某些依赖从预构建的过程中排除。

4. Vite 底层所深度使用的两个构建引擎: Esbuild 和 Rollup 。

5.Esbuild 到底在 Vite 的构建体系中发挥了哪些作用？
5.1.依赖预构建阶段：作为 Bundle 工具
在开发阶段的依赖预构建阶段，一般来说， node_modules 依赖的大小动辄几百 MB 甚至上 GB ，会远超项目源代码，相信大家都深有体会。如果这些依赖直接在 Vite 中使用，会出现一系列的问题，这些问题我们在依赖预构建的小节已经详细分析过，主要是 ESM 格式的兼容性问题和海量请求的问题，不再赘述。总而言之，对于第三方依赖，需要在应用启动前进行打包并且转换为 ESM 格式。
5.2.单文件编译：作为 TS 和 JSX 编译工具
在 TS(X)/JS(X) 单文件编译上面，Vite 也使用 Esbuild 进行语法转译，也就是将 Esbuild 作为 Transformer 来用。
5.3.代码压缩:作为压缩工具
压缩效率较 Terser 提升了二三十倍。

5.Vite 到底基于 Rollup 做了哪些事情？
5.1 生产环境 Bundle
Vite 默认选择在生产环
境中利用 Rollup 打包，并基于 Rollup 本身成熟的打包能力进行扩展和优化，主要包含 3 个方面:
5.1.1.CSS 代码分割。如果某个异步模块中引入了一些 CSS 代码，Vite 就会自动将这些 CSS 抽取出来生成单独的文件，提高线上产物的 缓存复用率 。
5.1.2.自动预加载。Vite 会自动为入口 chunk 的依赖自动生成预加载标签 <link rel="modulepreload">，这种适当预加载的做法会让浏览器提前下载好资源，优化页面性能。
5.2 兼容插件机制(兼容 Rollup 插件 54)

6.Esbuild 中两个重要的 API，分别是 Build API 和 Transform API
6.1Build API：项目打包
6.2Transform API：单文件转译
