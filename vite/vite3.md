1.rollup

1.虽然 Rollup 能够打包 输出 出 CommonJS 格式的产物，但对于 输入 给 Rollup 的代码并不支持 CommonJS，仅仅支持 ESM。你可能会说，那我们直接在项目中统一使用 ESM 规范就可以了啊，这有什么问题呢？需要注意的是，我们不光要考虑项目本身的代码，还要考虑第三方依赖。目前为止，还是有不少第三方依赖只有 CommonJS 格式产物而并未提供 ESM 产物，比如项目中用到 lodash 时，打包项目会出现这样的报错：

2.rollup 配置
2.1Rollup 基本配置项:rollup.config.js
2.2JavaScript API 的使用：两个经典的 API: rollup.rollup 和 rollup.watch

3.rollup 的插件机制
对于一次完整的构建过程而言， Rollup 会先进入到 Build 阶段，解析各模块的内容及依赖关系，然后进入 Output 阶段，完成打包及输出的过程。对于不同的阶段，Rollup 插件会有不同的插件工作流程。可能你会有疑问，这两个阶段到底跟插件机制有什么关系呢？
3.1 实际上，插件的各种 Hook 可以根据这两个构建阶段分为两类: Build Hook 与 Output Hook 。
3.1.1 Build Hook 即在 Build 阶段执行的钩子函数，在这个阶段主要进行模块代码的转换、AST 解析以及模块依赖的解析，那么这个阶段的 Hook 对于代码的操作粒度一般为 模块 级别，也就是单文件级别。
3.1.2 Ouput Hook (官方称为 Output Generation Hook )，则主要进行代码的打包，对于代码而言，操作粒度一般为 chunk 级别(一个 chunk 通常指很多文件打包到一起的产物)。

3.2 除了根据构建阶段可以将 Rollup 插件进行分类，根据不同的 Hook 执行方式也会有不同的分类，主要包括 Async 、 Sync 、 Parallel 、 Squential 、 First 这五种。
3.2.1 Async & Sync
首先是 Async 和 Sync 钩子函数，两者其实是相对的，分别代表 异步 和 同步 的钩子函数，两者最大的区别在于同步钩子里面不能有异步逻辑，而异步钩子可以有。
3.2.2 Parallel
这里指并行的钩子函数。如果有多个插件实现了这个钩子的逻辑，一旦有钩子函数是异步逻辑，则并发执行钩子函数，不会等待当前钩子完成(底层使用 Promise.all )。
3.2.3 Sequential
Sequential 指串行的钩子函数。这种 Hook 往往适用于插件间处理结果相互依赖的情况，前一个插件 Hook 的返回值作为后续插件的入参，这种情况就需要等待前一个插件执行完 Hook，获得其执行结果，然后才能进行下一个插件相应 Hook 的调用。
3.2.4 First
如果有多个插件实现了这个 Hook，那么 Hook 将依次运行，直到返回一个非 null 或非 undefined 的值为止。比较典型的 Hook 是 resolveId ，一旦有插件的 resolveId 返回了一个路径，将停止执行后续插件的 resolveId 逻辑。
3.3 实际上不同的类型是可以叠加的， Async / Sync 可以搭配后面三种类型中的任意一种，比如一个 Hook 既可以是 Async 也可以是 First 类型。

4.Rollup 插件机制（需要再次学习）

5.vite 插件机制（需要再次学习）

6.vite HMR(需要再次学习)
Vite 作为一个完整的构建工具，本身实现了一套 HMR 系统，值得注意的是，这套 HMR 系统基于原生的 ESM 模块规范来实现，在文件发生改变时 Vite 会侦测到相应 ES 模块的变化，从而触发相应的 API，实现局部的更新。

7.vite 代码分割

8.Vite 中语法降级与 Polyfill

9.Vite ssr
9.1 传统客户端渲染(CSR)的问题：
首屏加载速度比较慢；对 SEO(搜索引擎优化) 不友好
9.2 服务端渲染(SSR)是如何解决这些问题的呢？
在 SSR 的场景下，服务端生成好完整的 HTML 内容，直接返回给浏览器，浏览器能够根据 HTML 渲染出完整的首屏内容，而不需要依赖 JS 的加载，这样一方面能够降低首屏渲染的时间，另一方面也能将完整的页面内容展现给搜索引擎的爬虫，利于 SEO。当然，SSR 中只能生成页面的内容和结构，并不能完成事件绑定，因此需要在浏览器中执行 CSR 的 JS 脚本 完成事件绑定 让页面拥有交互的能力 这个过程被称作 hydrate (翻译为 注水 或者 激活 )。同时，像这样服务端渲染 + 客户端 hydrate 的应用也被称为 同构应用 。
 